# 문제 회고

## 접근
문제 자체는 크게 어려운 내용으로 보이지 않았다.
임의의 Stack에 값들을 넣으면서 앞서 넣어진 값들 중 자신의 값보다 더 큰 값을 return 혹 자신의 값보다 큰 값이 없다면 0을 return 하면 될 것 같았다.

### 첫번째 시도
Stack에 값을 모두 넣어놓고 다시 맨앞부터 값을 찾기에는 시간 낭비일 것 같아 스택에 값을 넣는 동시에 StringBuilder에 출력 값을 붙이려고 했다.

### 실패
가령 1번 탑의 검증과정이 끝나고 2번 탑을 검증하려할때, 기존의 스택을 유지해야하지만, 유지에 실패했다.

### 두번째 시도
첫번째 시도에서 얻을 수 있었던 `스택의 유지` 에 대해 고민하다가 스택을 복사하면 어떨까? 하는 생각을 하게 되었다.

### 실패
스택에 대해 좀 무지했어서

```java
Stack<Integer> a = new Stack<>();
Stack<Integer> b = new Stack<>();

b = a;
```

위와 같은 식으로 복사를 시도했었다.

하지만 Stack은 레퍼런스 참조를 하기 때문에 a값이 이후 변경되면 b 값 또한 변경되어 내가 원하는 동작을 하지 않았다.

### 세번째 시도
.clone(), .addAll 같은 깊은 복사, 얕은 복사의 개념을 공부하고 적용해봤다.


### 실패
복사 자체는 내가원하는대로 이루어졌지만 메모리 초과 오류가 발생하면서 제출 실패가 되고 말았다.

추가로 Stack에서 복사를 하게되면 순서보장이 되지않는다는것을 알게 되었다.

### 네번째 시도
스택의 순서를 보장하며 메모리를 아끼기위해 두가지를 고민했다.

1. input을 받는과정을 Scanner 대신 BufferedReader와 StringTokenizer를 사용한다.
2. Stack의 제네릭형을 배열로 선언해 주소값을 사용한다.

문제는 탑의 높이를 출력하는게 아닌 먼저 닿은 탑의 idx를 출력하는것이므로 배열의 인덱스를 사용해 idx를 출력해준다.

