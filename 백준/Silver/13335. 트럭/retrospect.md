# 문제 회고

## 접근
큐와 관련된 알고리즘 문항으로 이 문제를 만났다.
그래서 그런지 머리가 너무 큐를 써야한다는 강박에 시간이 꽤 걸린 문제이다.

### 첫번째 시도
트럭의 개수는 트럭 각 무게를 넣을때 갯수로만 사용한다고 가정하고 길이는 시간에만 사용할 것 같았다.
우선 하중을 우선적으로 고려하고 접근했다.

길이가 같더라도 가장 짧은 시간에 보내려면 최대가능한 트럭들을 꼬리에 꼬리를 물고 한번에 보내는게 가장 빠를 것 같다고 생각해 접근했다.
-> Queue에 배열을 최대하중보다 작거나 같을때까지 차례로 넣는 방법을 고려했다.

### 실패
큐에 입력값을 무게가 될때까지 차례로 넣고 구현하려고 했지만 시간을 추적하는 과정이 너무 복잡하여 실패했다.

### 두번째 시도
다리에 집중하지말고, 단위시간 단위로 변하는 트럭들의 움직임에 집중해보기로 한다.

```txt
1. 단위시간마다 바뀌는 상황을 추적
2. 그러면 Queue는 언제 사용해?
3. Queue도 동시에 무게관리에 사용하면 될 것 같다.
4. Queue의 크기를 그럼 다리길이만큼 유지해보자!
5. 유지하되 Queue를 밀고 나가야 시간관리에 편하지않을까?
6. queue.add(0)으로 비어있는 시간을 표현하면서 트럭을 밀고 나가자
```

위와 같은 고민을 하고 구현을 시작했다.

다리가 비어있을때, 또는 트럭이 이동하는 과정은 위에서 0으로 표현하기로 했기에

```java
for (int i = 0; i < lengthOfBridge; i++) {
            queue.add(0);
        }

```
다음과 같이 초기 다리위 값을 설정해줬다.

### 핵심로직
이 문제의 핵심은 다리가 버틸 수 있는 최대한 가까운 무게가 되도록 트럭을 다리에 올리는 것이다.

```java
for (int truckWeight : truckWeights){
            while(true){
                sumOfWeight -= queue.poll();

                if (sumOfWeight + truckWeight <= maximumWeightOfBridge){
                    queue.add(truckWeight);
                    sumOfWeight += truckWeight;
                    time++;
                    break;
                }
                else{
                    queue.add(0);
                    time++;
                }
            }
        }
```

트럭이 다 지나가는게 목표이므로 트럭의 개수만큼 반복을 거친다.

내부에서는 지금까지 올린 트럭과 지금 올릴 트럭의 합이 다리가 버티는 하중을 넘는지 확인한다.

넘는다면 queue.add(0)을 통해 트럭을 전진시키고 넘지않는다면 트럭을 추가하고 다리 위 무게를 다시 조정한다.

위 두 동작 모두 시간을 늘려준다.

### 문제발생?
로직이 정확했고 문제의 테스트 케이스와 내가 만든 임의의 테스트 케이스들을 돌려봤는데, 코드에 이상한 점이 있었다.

조금씩 값이 모자라는 부분이 있어서 계속 해법을 찾아해맸다.

### 문제해결
원인은 사실 엄청 간단한거였다.... ㅎ

코드 상으로 다리위에 마지막 트럭이 올라가면 그 시점의 time이 출력되었는데, 마지막 트럭이 다리를 건너는 시점이 정답이기에 마지막으로 다리의 길이를 추가해줘야했다.




